# <a id="home"></a> Missing Number

**Table of Content:**
- [О задаче](#about)
- [Brute Force](#brute)
- [Bit Manipulation](#bit)
- [Single number problem](#single)


## [↑](#home) <a id="about"></a> О задаче
Данный разбор посвящён задаче про поиск отсутствующего элемента в массиве. Разбор основан на материале от Влада Тен: **"[LeetCode Patterns #2 - Missing Number](https://www.youtube.com/watch?v=nTt3929ik8U&list=PLyHj6yBbnkUgC6T9RpPxEBUv3My9lPd7m&index=3)"**.

Данная задача на Leetcode: **"[268. Missing Number](https://leetcode.com/problems/missing-number/)"**.

Требуется реализовать следующий метод:
```java
class Solution {
    public int missingNumber(int[] nums) {
        //
	}
}
```
Например, дан массив [3,0,1]. n=3, то есть максимальное число будет 3. Но т.к. у нас ещё и ноль есть, то такая последовательность в любом случае не влезет в массив.

Как и у многих задач для решения этой задачи есть несколько подходов.


## [↑](#home) <a id="brute"></a> Brute Force
Самое простой для понимания и запоминания метод - метод грубой силы, он же "brute force", оно же "решение в лоб":
```java
class Solution {
    public int missingNumber(int[] nums) {
        int expected = 0;
        for (int i = 0; i <= nums.length; i++) {
            expected = expected + i;
        }
        
        int actual = 0;
        for (int num : nums) {
            actual = actual + num;
        }
        return expected - actual; 
    }
}
```
Тут всё просто. Если сложить все элементы "как должно быть" (т.е. без пропуска) и сложить все элементы "как есть", а потом вычесть из "как должно быть" полученное "как есть", то мы и получим пропущенное число.

Данное решние можно ещё и упростить, если использовать формулу суммы арифметической прогрессии: ``n(n+1)/2``. Тогда получение ожидаемой суммы упростится:
```
int l = nums.size();
int sum = (l * (l + 1))/2;
```
Дальше останется только из этой суммы вычесть все элементы из массива. Число, которое останется, и будет нашим пропущенным числом.


## [↑](#home) <a id="bit"></a> Bit Manipulation
Есть на сайте leetcode посмотреть в раздел "Related topics" этой задачи, то мы увидим "Bit Manipulation". В реальной разработке это стоило бы делать только в случае критичности для производительности, т.к. будет понятно не всем разработчикам. Поэтому, давайте станем тем, кому это всё таки было бы понятно.

Основа решения - так называемое "exclusive OR" или же просто "XOR".\
XOR обозначается как ``^`` и имеет несколько важных правил:
- n ^ n = 0
- n ^ 0 = n
- a1^a2^a3^..^an=a, a1^a2^a3^..^an-1=b, тогда a^b=an
- нет разницы, в каком порядке указаны числа

Тогда, наше решение может выглядеть следующим образом:
```java
class Solution {
    public int missingNumber(int[] nums) {
        int missing = nums.length; 
        for  (int i = 0; i < nums.length; i++)  { 
            missing = missing ^ i;
            missing = missing ^ nums[i];
        } 
        return missing ; 
    }
}
```
Тут логичный вопрос, почему мы устанавливаем изначальное значение missing как nums.length, т.е. как максимальное значение. Причина как раз в том правиле, что при XOR числа на ноль мы получаем это же число.

А теперь рассматрим самый минимальный случай:
```
Дан массив [0], т.е. n=1, максимальное значение 1. Ожидаем результат 1.
Идём по индексам: 0^0=0
Идём по числам: 0^0=0 , а хотели получить 1. 
Итого: ошибочный результат.

Идём по индексам: 1^0=1
Оба значения в массиве отработают правильно:
- [0] : 1 ^ 0 = 1
- [1] : 1 ^ 1 = 0
Итого: правильный результат.
```


## [↑](#home) <a id="single"></a> Single number problem
После того, как мы ознакомились c решением при помощи XOR мы можем решить задачу **"[136. Single Number](https://leetcode.com/problems/single-number/)"**. В ней сказано, что у нас есть массив, состоящий из парных чисел, но одно из них не имеет пары. Нужно найти это число.

Кроме того, задача упрощена тем, что ``1 <= nums.length <= 3 * 104``, т.е. мы не столкнёмся с проблемой 0 ^ 0.

На самом деле эта задача очень похожа на Missing Number. Часто получается так, что одна задача - это чуть изменённая другая. Так и в нашем случае. Ведь если представить, что взяли массив и добавили в него все числа из провреямого массива (с пропуском) + все числа из эталонного массива (без пропуска), то вот она наша задача. Тогда и решение будет таким же:
```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i : nums){
            result = result ^ i;
        }
        return result;
    }
}
```